# 哈希算法
## 一，哈希算法的概念

### 1，什么是哈希算法
哈希算法 (Hash Algorithm)又称散列算法、散列函数、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。 哈希算法将数据重新打乱混合，重新创建一个哈希值。 哈希算法主要用来保障数据真实性 (即完整性)，即发信人将原始消息和哈希值一起发送，收信人通过相同的哈希函数来校验原始数据是否真实.
<img src="D:\202305java工具\笔记\_pic\aaa.png" >
将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值（散列值）．一个优秀的哈希算法需要满足：
从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；
散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；
哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。



### 2，哈希值的特点
  * 哈希值是二进制值；
  * 哈希值具有一定的唯一性；
  * 哈希值极其紧凑；
  * 要找到生成同一个哈希值的2个不同输入，在一定时间范围内，是不可能的。

![img](D:\202305java工具\笔记\_pic\WO7AQB[%$EOY7VZ{]QEAGH.png)

正因为哈希值的这些特点，使得哈希算法应用在加密领域成为可能。哈希算法在加密领域的应用，源于哈希算法的不可逆性，对于用户输入的密码，通过哈希算法可以得到一个哈希值。并且，同一个密码，生成的哈希值总是相等的。这样，服务器就可以在不知道用户输入的密码的情况下，判断用户输入的密码是否正确。

## 二，哈希算法的具体实现

数组：

<img src="D:\202305java工具\笔记\_pic\111.png" >

哈希表：

<img src="D:\202305java工具\笔记\_pic\222.png" >
<img src="D:\202305java工具\笔记\_pic\888.png" >
<img src="D:\202305java工具\笔记\_pic\333.png" >

### 1.哈希表
根据设定的哈希函数H（key）和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便成为哈希表，这一映像过程称为哈希造表或散列，所得存储位置称哈希地址或散列地址。

**这里的哈希函数用的就是某种哈希算法，映射的地址就是哈希值。**

在不考虑哈希冲突的情况下，哈希表的时间复杂度为O（1）：
在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。
存数时：
当前元素的关键字 ，通过哈希函数映射到数组中的某个位置（关键字在数组中的偏移量），通过数组下标一次定位就可完成操作。
取数时：
查找操作同理，先通过哈希函数计算出实际存储地址（偏移地址），然后从数组中对应地址取出即可。

哈希函数有很多不同形式的表现方式，但都是不可逆的

模运算/求余

<img src="D:\202305java工具\笔记\_pic\444.png" >
<img src="D:\202305java工具\笔记\_pic\555.png" >
<img src="D:\202305java工具\笔记\_pic\666.png" >

####  哈希冲突
哈希映射是将数据映射到有限的地址范围内，所以在将一个较大的数据集映射到有限的地址空间时，难以避免会将两个不同的数据映射到同一个地址，这就是哈希冲突。
鸽巢原理（也叫抽屉原理）：如果有 10 个鸽巢，有 11 只鸽子，那肯定有 1 个鸽巢中的鸽子数量多于 1 个，换句话说就是，肯定有 2 只鸽子在 1 个鸽巢内。

test01();

哈希冲突会非常影响哈希表的存取效率。哈希冲突的可能性与哈希表的大小以及哈希算法有关系。有很多处理哈希冲突的方法不拓展。

<img src="D:\202305java工具\笔记\_pic\777.png" >

- 开放寻址法
只用数组一种数据结构存储，继承了数组的优点，对CPU缓冲友好，易于序列化。但是对内存的利⽤率并不如链表法，且冲突的代价更高。当数据量⽐较⼩、装载因⼦⼩的时候，适合采⽤开放寻址法。这也是Java中的ThreadLocalMap使⽤开放寻址法解决散列冲突的原因。常用的方法有线性探查法和二次探查法。

- 封闭寻址法
封闭寻址法不把关键字存储在表中，而是把散列在相同位置的所有关键字都存储在一个“吊挂”在那个位置上的数据结构中。最常见的就是链表，在java中java.util.HashMap就采用这样的设计

链表法对内存的利⽤率⽐开放寻址法要⾼。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。链表法⽐起开放寻址法，对⼤装载因⼦的容忍度更⾼。基于链表的散列冲突处理⽅法⽐较适合存储⼤对象、⼤数据量的散列表，⽽且，⽐起开放寻址法，它更加灵活，⽀持更多的优化策略，⽐如⽤红⿊树代替链表。


### 2.hashcode
每个对象都有hashcode，对象的hashcode怎么得来的呢？
把任意长度的输入通过hash算法变换成固定长度的输出，该输出就是hashcode。
首先一个对象肯定有物理地址，在别的博文中会hashcode说成是代表对象的地址，这里肯定会让读者形成误区，对象的物理地址跟这个hashcode地址不一样，hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址，那么对象如何得到hashcode呢？

通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode。所以，hashcode就是在hash表中对应的位置。

### 3.hashcode的作用
总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。

那么这里就有一个比较严重的问题了： 要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？

这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。
于是，Java采用了哈希表的原理。

这样一来，当集合要添加新的元素时，

先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。

如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；

如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。

test02()

### 4. equals()和hashcode的关系

- 1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。
- 2、如果两个对象不equals，他们的hashcode有可能相等。
- 3、如果两个对象hashcode相等，他们不一定equals。
- 4、如果两个对象hashcode不相等，他们一定不equals。

### 5.为什么equals()重写的话，建议也一起重写hashcode方法？

在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。

1.在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。

2.如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。

3.如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。

### 6.总结
1、equals方法用于比较对象的内容是否相等（覆盖以后）
2、hashcode方法只有在集合中用到
3、当覆盖了equals方法时，比较对象是否相等将通过覆盖后的equals方法进行比较（判断对象的内容是否相等）。
4、将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。


## 三、应用
### 1，哈希算法在HashMap类中的应用
java中的集合，比如HashMap/Hashtable/HashSet等，在实现时，都用到了哈希算法。当我们向容器中添加元素时，我们有必要知道
这个元素是否已经存在。
从实现上来说，java是借助hashcode()方法和equals()方法来实现判断元素是否已经存在的。当我们向HashMap中插入元素A时，首先，
调用hashcode()方法，判断元素A在容器中是否已经存在。如果A元素的hashcode值在HashMap中不存在，则直接插入。否则，接着调用
equals()方法，判断A元素在容器中是否已经存在。hashcode()的时间复杂度为O(1)，equals()方法的时间复杂度为O(m)，整体的时间复杂度
就是：O(1) + O(m)。其中，m是桶的深度。桶的深度是一个什么概念呢，桶的深度是指具有相同hashcode值得元素的个数，也就是发生哈希
碰撞的元素的个数。

### 2，哈希算法在String类中的应用
Sring类重写了Object类的equals()方法和hashcode()方法。hashcode()方法的源代码如下：
~~~java
    public int hashCode() {  
    int h = hash;  
    if (h == 0) {  
        int off = offset;  
        char val[] = value;  
        int len = count;  
      
            for (int i = 0; i < len; i++) {  
                h = 31*h + val[off++];  
            }  
            hash = h;  
        }  
        return h;  
    }  
~~~

~~~java
    String str = "abcdef";  
      
    // 第一步 = (int)'a'  
    // 第二步 = (31 * (int)'a') + (int)'b'  
    // 第三步 = 31 * ((31 * (int)'a') + (int)'b') + (int)'c'  
    // 第四步 = 31 * (31 * ((31 * (int)'a') + (int)'b') + (int)'c') + (int)'d'  
    // 第五步 = 31 * (31 * (31 * ((31 * (int)'a') + (int)'b') + (int)'c') + (int)'d') + (int)'e'  
    // 第六步 = 31 * (31 * (31 * (31 * ((31 * (int)'a') + (int)'b') + (int)'c') + (int)'d') + (int)'e') + (int)'f'  
      
    // 上面的过程，也可以用下面的方式表示  
      
    // 第一步 = (int)'a'  
    // 第二步 = 31 * (第一步的计算结果) + (int)'b'  
    // 第三步 = 31 * (第二步的计算结果) + (int)'c'  
    // 第四步 = 31 * (第三步的计算结果) + (int)'d'  
    // 第五步 = 31 * (第四步的计算结果) + (int)'e'  
    // 第六步 = 31 * (第五步的计算结果) + (int)'f'  
      
    int hashcode = 31 * (31 * (31 * (31 * ((31 * (int)'a') + (int)'b') + (int)'c') + (int)'d') + (int)'e') + (int)'f';  
    System.out.println("abcdef的hashcode = " + hashcode);        // abcdef的hashcode = -1424385949  
    System.out.println("abcdef的hashcode = " + str.hashCode());  // abcdef的hashcode = -1424385949  
      
}  
~~~


### 3.哈希算法在Object中的应用	
~~~
    public static int hashCode(Object a[]) {
        if (a == null)
            return 0;

        int result = 1;

        for (Object element : a)
            result = 31 * result + (element == null ? 0 : element.hashCode());

        return result;
    }
~~~

